'number' + 23 + 32 // буде рядок number2332, тому що 'numer' конкатенується з числами
41 + 1 + 'number' // буде 42number, спочатку математична операція 41 + 1, потім її результат 42 буде конкатенуватись зі строкою number
null + 1 // результат буде null, null конвертується в 0
'five' + + 'two' // результат буде fiveNaN, строка конкатенується з "+ 'two'", + перед 'two' означає повернення числової репрезентації обʼєкта, але розпарсити 'two' неможливо, тому там буде NaN
2 && 7 // результат 7, бо && повертає значення останнього операнду який був true
+'40' + +'2'; // результат буде число 42, + перед числами поверне нам 40 і 2 відповідно, і потім їх додасть
'10' - 5 === 6; // результат буде false, '10' - 5 буде 5, а строга рівність 5 === 6 буде false
true + false // буде 1, бо це математична операція а true = 1, false = 0
'4px' - 3 // буде NaN бо 4px неможливо перетворити на число
'4' - 3 // результат буде 1, 4 буде перетворено на чисто, 4 - 3 = 1
'2' + 3 ** 2; // результат буде 29, ** має вищий за додавання приорітет
12 / '6' // результат буде 2, '6' буде перетворено на число
23 + 42 + 'number' // 65number, код іде зліва на право, спочатку додавання 23 і 42, потім конкатенація з number
'10' + (5 === 6); // 10false, рядок 10 буде конкатенуватись з результатом 5 === 6, який є false
'number' + 15 + 3 // number153, number конкатенується з 15, оскільки + мають однаковий пріорітет, код іде зліва направо то буде number15 + 3, ше одна конкатенація
undefined + 1; // NaN, оскільки undefined не число
'true' == true // результат буде false, оскільки рядок 'true' не булевому значенню true
false == 'false' // те ж саме що вище, булевий false не дорівнює рядку 'false'
null == '' // false, пустий рядок це строка, а строка не дорівнює null
3 ** (9 / 3); // результат буде 27, спочатку за пріоритетом іде ділення 9 / 3, потім результат 3 буде приведено у ступінь 3
!!'false' == !!'true' // результат буде true, !! перетворює строку на boolean, і буде true, якщо строка не пуста, ну а true == true
0 || '0' && 1 // результат буде 1, 0 || '0' поверну '0', а '0' && 1 поверне 1, бо це останній операнд який є true
1 < 2 < 3 // true бо читається зліва на право
'foo'+ + +'bar' // fooNaN, робимо конкатенацію з NaN, бо з +'bar' неможливо дістати number
3 ** 2 / 3; // результат буде 3, 3 ** 2 буде 9, 9 / 3 = 3, так як операції ідуть зліва на право а у ступіня і ділення однаковий пріоритет
1 < 2 > 3 // false, 1 меньше двух це true, але 2 меньше 3, тому false
(+null == false) < 1; // результат буде false, +null перетворюється на 0, 0 порівнюється з false, який теж 0, і отримаємо true, true не меньше 1, адже true це теж 1
false && true || true // && має вищий пріоритет, спочатку порівнюємо false && true, буде false оскільки && повертає перший false який знайде, 
// потім false || true, поверне true, якщо ліва частина || має значення false, то він повертає праву частину
false && (true || true); // спочатку буде виконано true || true, що поверне true, потім false && true, який поверне false, бо && повертає значення першого false який він знаходить
(+null == false) < 1 ** 5; // результат буде false, спочатку ми обробляємо +null == false, +null буде перетворено на 0, 0 == false буде true, потім порівнюємо true < 1 ** 5, 1 у будь якій ступені буде 1, а true == 1, тому true < 1 буде false
